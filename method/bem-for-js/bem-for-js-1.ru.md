## БЭМ для JavaScript

В разработке интерфейсов важно помнить, что сайт – это растущий организм.
Ситуации, когда в коде сайта нет определенной структуры и фиксированных правил написания, приводят к сложностям в процессе разработки и поддержки. Чтобы обеспечить долгую и безоблачную жизнь вашему проекту следует начать с общего подхода, с методологии.

### Зачем в JavaScript компонентный подход

Те времена, когда веб-сайты состояли из статического контента и нескольких скриптов для обработки, остались позади.

Современные пользователи становятся все требовательнее: веб должен быть быстрыми, динамическим, удобным, интерактивным и уметь адаптироваться под запросы потребителя. Сайты уже не представляют собой несколько страниц текста с картинками и ссылками; сейчас они обрабатывают информацию и решают многие задачи. Возрастание роли веб-приложений очевидны – они не требуют установки у пользователя и их гораздо проще настраивать под этого самого пользователя. Программами «из коробки» теперь все чаще можно воспользоваться непосредственно в вашем любимом браузере.
Разработка становится все сложнее и интереснее: сайты увеличиваются в объемах, растет количество постоянных пользователей, владельцы сайта хотят угодить всем, так как напрямую от этого зависит их прибыль, повышается конкуренция. Сайт должен быть очень мобильным и уметь реагировать на все изменения окружающей среды практически мгновенно. А что же в таком случае остается делать разработчику? Ответ один: чтобы выжить, ему необходимо учиться оптимизировать разработку, умело пользоваться всем своим кодом и быстро отыскивать проблемные места, устраняя ошибку локально, не затрагивая никакие другие части кода.

Как все это воплотить в жизнь? Типичный человеческий подход к преодолению сложной проблемы — дробление ее на более простые части. Идея разделения на компоненты не нова. Она в полном объеме реализована в ООП. Нам остается только перенять этот богатый опыт.

Будущее (кажется, что это уже настоящее) веб-приложений – за переходом на компонентную структуру.

Компонентный подход в JavaScript позволяет объединять сущности по общему признаку и организовывать их в соответствии с определенными правилами и ограничениями. Не имеет значения, как этот подход реализован, потому что у каждого компонента есть свои методы, которые знают все о себе. [Общение с внешними блоками](#independent-blocks) происходит либо через родителя, либо через каких-то посредников.

Компонентная структура обеспечивает гибкость контроля версий и помогает избежать конфликтов во время ведения параллельной разработки. Перенос логики, связанной с конкретными блоками, в отдельные файлы, улучшает читаемость кода и ускоряет процесс создания и корректировки проекта. Именно эту задачу решает БЭМ.

## Применение методологии БЭМ к JavaScript

В процессе эволюции технологий написания сайтов появился БЭМ. Суть данного подхода – разбиение страницы на блоки и элементы. Определение свойств, их значений и дополнительной функциональности блоков и элементов выполняется с помощью модификаторов. Еще одно ключевое понятие БЭМа – [уровни переопределения](https://ru.bem.info/tools/bem/bem-tools/levels/). Они позволяют расширять и дополнять поведение одного и того же блока.

Изначально перед разработчиками ставились задачи отображения внешнего вида страницы, поэтому методология БЭМ применялась больше для именования классов в CSS. Как и CSS JavaScript пишется к каждому блоку отдельно и располагается непосредственно в самом блоке. Блок становится независимым и в функциональном плане. JavaScript приводит в действие какие-то модификаторы и это те самые модификаторы, которые приводят в действие какие-то CSS свойства. Они напрямую связаны и разделять их нет смысла, поскольку JavaScript и CSS оперирует одними терминами.

Как же применить БЭМ-методологию к JavaScript? БЭМ вводит единую семантику на всех уровнях (HTML, CSS, JavaScript, шаблоны, дизайн интерфейсов) и предоставляет единый гибкий API поверх разнообразного набора методов работы с DOM. А на уровне файловой системы все про одну сущность складывает в одну папку, предназначенную для повторного использования и расширения.

Чтобы на деле понять как работает подход БЭМ, понадобиться разобраться в следующих определениях, особенностях подхода и принципах:

*   [декларативный подход](#declaration)
*   [взаимодействие блоков](#independent-blocks)
*   [модификатор](#modifier)
*   [метод](#method)
*   [событие](#event)
*   [изменение поведения блока](#customization)
*   [инициализация](#initialization)


<a name="declaration"></a>

### Декларативный подход

Важной особенностью БЭМ технологии является декларативный принцип. Подобно работе декларативных языков программирования, JavaScript-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.

Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента. При декларировании какой-то сущности известно, что она имеет определенные состояния и при переходе в эти состояния с ней происходят конкретные действия, а при возвращении к предыдущему состоянию с ней случаются обратные действия.

<Пример>

<Расшифровка примера>

<a name="independent-blocks"></a>

### Способы взаимодействия блоков

Блок в БЭМ – это независимый компонент, который можно переместить в любое место на странице, в том числе и в другой блок или же на другой проект. Блок может поддерживать разные технологии – HTML, CSS, JavaScript и т.п. БЭМ-методолгия позволяет на уровне проекта изменить внешний вид или поведение существующего блока, добавить новые блоки. Однако, несмотря на независимость блоков, на уровне JavaScript они обязаны общаться друг с другом.

### Написание JavaScript-кода с сохранением независимости блоков

Простой пример поможет понять как происходит взаимодействие блоков.

**Описание**

Есть форма, перед отправкой которой необходимо проверить, что введено корректное значение, и в случае ошибки показать попап с предупреждением.

Выглядит это следующим образом:

```html
<form class="form" action="/">
    <input class="input" name="email">
    <input class="button" type="submit">
    <div class="popup">Пожалуйста, введите корректный email</div>
</form>
```

```css
.popup {
    display: none;
}

.popup_visible {
    display: block;
}
```
Чтобы описанная конструкция заработала необходимо написать JavaScript-код.

### Реализация в старом стиле

Приведенный пример показывает, как делать **не надо**.

```js
$('.button').on('click', function(e) {
    if (!/\S+@\S+\.\S+/.test($('.input').val())) {
        $('.popup').addClass('popup_visible');
        return false;
    }
});
```
Согласно представленному коду, кнопка «знает» про поле ввода и попап, кроме того явно предполагается, что она находится внутри формы.

Однако реальность такова, что проекты не стоят на месте, они развиваются. Приходит момент, когда необходимо что-то добавить, переместить или изменить. Процесс реорганизации внутренней структуры в представленном коде, будь то удаление одного из компонентов или появление новых элементов, приведет к его поломке. При возможном переиспользовании такой кнопки, обязательно придется применить все компоненты с такими же классами и гарантировать, что больше нигде на странице они не встретятся.

**Результат** <br>
Данный код сложно и поддерживать, и нерационально реиспользовать, если только не делать точную копию проекта.

#### Улучшенная реализация

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.input', this).val())) return true;
    e.preventDefault();
    $('.popup', this).addClass('popup_visible');
});
```
**Изменения** <br>
Согласно новому коду, форма, за все что происходит с ней, отвечает сама. Теперь компоненты внутри ничего не знают о существовании друг друга. При необходимости можно взять кнопку и перенести ее на другой проект, поскольку она стала независимой. В этом случае кнопка не будет нести в себе знание о какой-то форме, поле ввода и попапе.

**Результат** <br>
Все селекторы вынесены за рамки контекста формы и теперь можно добавлять любое количество новых полей ввода, попапов и кнопок за пределами формы – ничего не сломается. <br>
Но, если добавить еще одно поле, придется реорганизовывать код. Кроме того, чтобы гарантировать перекрытие попапом любых других элементов на странице, необходимо положить его в самом конце DOM-дерева, перед закрывающим тегом `</body>`.

#### Миксы

**Изменения** <br>
Решить задачу с добавлением ещё одного поля можно при помощи миксов. Микс — это объединение нескольких блоков на одном DOM-узле. <br>
Попап вынесен из формы и к нему добавлено еще одно поле. А сами поля смиксованы с элементами формы.


```html
<form class="form" action="/">
    <input class="input form__login" name="login">
    <input class="input form__email" name="email">
    <input class="button" type="submit">
</form>
<div class="popup form__hint">Пожалуйста, введите корректный email</div>
```
Теперь код выглядит так:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    $('.form__hint').addClass('popup_visible');
});
```
**Результат** <br>
Исправлены предыдущие проблемы, но появилась новая: если на странице окажется несколько форм, как каждая из них найдет свой попап?

В качестве решений этой проблемы представлено несколько вариантов:

*   [Один блок на нескольких DOM-узлах](#distrib_block)
*   [Использование посредника](#mediator)

<a name="distrib_block"></a>

#### Один блок на нескольких DOM-узлах

**Изменения** <br>
В этом случае реализован механизм, который позволит выражать один блок на нескольких DOM-узлах. Схематично он может выглядеть так:

```html
<form class="form" action="/" data-id="1">
    <input class="input form__login" name="login">
    <input class="input form__email" name="email">
    <input class="button" type="submit">
</form>
<div class="popup form form__hint" data-id="1">Пожалуйста, введите корректный email</div>
```
Форме добавлен data-атрибут с идентификатором и помимо элемента к попапу примиксована сама форма с таким же идентификатором.
Теперь в коде можно указать, что необходим элемент `hint` именно этого блока `form`, а не какого-то другого:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    $('.form__hint').filter('.form[data-id=' + $(this).data('id') + ']').addClass('popup_visible');
});
```
**Результат** <br>
Теперь через конкретный data-атрибут можно найти нужный элемент.

<a name="mediator"></a>

#### Использование посредника

Следующее решение позволяет сохранить независимость блоков, но избавиться от необходимости вносить изменения в DOM.
Для этого необходимо воспользоваться паттерном проектирования [Посредник](https://ru.wikipedia.org/wiki/Посредник_%28шаблон_проектирования%29).

Паттерн обеспечит взаимодействие компонентов таким образом, что они ничего не будут знать друг о друге, но будут знать о существованиии посредника. Вся коммуникация происходит на основе сообщений, которые компоненты публикуют и слушают на посреднике.

**Изменения** <br>
В качестве самого простого примера посредником может выступить `body`. Он всегда присутствует в коде и знает о всех компонентах, которые находятся внутри, к тому же может обеспечить обмен сообщениями.

```html
<body class="page">
    <form class="form" action="/">
        <input class="input form__login" name="login">
        <input class="input form__email" name="email">
        <input class="button" type="submit">
    </form>
    <div class="popup"></div>
</body>
```
Код выглядит так:

```js
var page = $('.page');

page.on('error', function(e, data) {
    $('.popup')
        .text(data)
        .addClass('popup_visible');
});

$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    page.trigger('error', 'Ошибка валидации');
});
```
**Результат** <br>
В случае ошибки валидации форма сообщает об этом посреднику — `page`. Все компоненты, которые должны реагировать на это событие, могут «подписаться» на него через `page.on()`.

<a name="modifier"></a>

### Модификаторы

Согласно БЭМ-методологии, состояние блока и его элементов описывается модификаторами. Модификатор задает блоку определенное состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение. Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.

Каждому блоку можно установить один или несколько модификаторов. Блок может не иметь модификаторов. Список допустимых модификаторов и их значений определяет разработчик блока.

Согласно БЭМ-модификаторы могут быть не только у блоков, но и у элементов. Используемые для этого методы похожи.

Простой модификатор — частный случай, когда важно только наличие или отсутствие данного модификатора у блока, а его значение несущественно. Например, модификатор описывающий состояние «отключен»: disabled

#### Управление модификаторами

Модификаторы могут добавляться, удаляться и менять значение.

#### Установка триггеров

Триггеры, выполняемые при установке модификаторов, описываются в декларации блока.

В качестве параметров триггерам передаются:

*   имя модификатора;
*   выставляемое значение модификатора.

```js
{
    'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    'mod2': {
        'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    'mod3': {
        'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        '': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
```

<a name="method"></a>

### Методы

Чтобы динамически изменять состояния блоков и элементов, есть специальные методы для установки и снятия модификаторов. В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна. Например, какой-то блок при установке модификатора disabled скрывает показанный попап.

Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определенные в блоке методы могут быть вызваны им самим или другими блоками.

Например, как выглядит какой-то метод какого-то блока.

Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределен. Подробнее об этом в пункте [Изменение поведения блока](#customization).

<Пример>

<Расшифровка примера>

<a name="event"></a>

### События

События играют важную роль в JavaScript. Специальные методы позволяют работать с событиями как на DOM-узлах, соответствующих блокам, так и на BEM-объектах (JavaScript-объектах, представляющих экземляры блоков).

<Пример>

<Расшифровка примера>

<a name="customization"></a>

### Изменение поведения блоков

Можно переопределять и доопределять методы блока и функции реакции на изменения модификаторов.

#### Переопределение поведения

#### Расширение поведения

<a name="initialization"></a>

### Инициализация

Работа блока начинается с его инициализации. В этот момент у блока появляется модификатор js_inited.
Многим блокам нет необходимости делать сразу же полную инициализацию. Инициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.

## Подведем итоги

В наше время значение веб-приложений возростает с каждым днем, появляются новые и растут в объеме старые сайты. Повышение запросов к качеству и скорости выполнения проектов приводит к поиску новых технологий, которые облегчат разрабоку. БЭМ обеспечит эффективное задействование имеющегося кода и продление существования проекта. Ключевые преимущества в использовании БЭМ-методологии:

* **расширяемость и быстрая разработка.** Связывая на уровне кода CSS и JS в одних терминах, складывая все рядом на уровне файловой системы, вы получаете независимые компоненты, которые знают все о себе и их легко можно переносить между проектами.
* **оптимизация процесса.** Декларативность позволяет сохранить с одной стороны независимость компонентов, а с другой стороны позволяет повлиять на них, в том числе не только из CSS, но и из JavaScript, и в каждом конкретном случае добавить новую функцинальность, не ломая базовую.
* **высокая готовность к частым изменениям**

Теперь вы можете оперировать принципами БЭМ при написании JavaScript-кода. Чтобы ознакомиться со специализированным JavaScript-фреймворком, который разработан по БЭМ-методологии читайте статью [i-bem.js: руководство пользователя](https://ru.bem.info/technology/i-bem/current/i-bem-js/).
