БЭМ и JavaScript

В БЭМ-методологии JavaScript используется для «оживления» веб-страницы и рассматривается как одна из технологий реализации блока. На ровне с другими технологиями (CSS, HTML, шаблоны), JavaScript подчиняется основным правилам БЭМ-методологии:
  * Использует единые термины блоков, элементов и модификтаоров.
  * Формирует имена БЭМ-сущностей по общим правилам именования.
  * Следует принципам организации файловой структуры БЭМ-проекта.

```files
block-name/
  block-name.css    # Внешний вид блока
  block-name.tmpl   # Шаблоны для генерации HTML-представления блока
  block-name.js     # Динамическое поведение блока в браузере
```

**Пример**

Блок логотип (`logo`) реализован в двух технологиях: шаблоне и стилях.

HTML-реализация:

```html
<a class="logo" href="/">Ваша крутая компания</a>
```
CSS-реализация:

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logok.png) no-repeat;
}
```

По [правилам организации файловой системы БЭМ-проекта](../filesystem/filesystem.ru.md) шаблон и стили находятся в директории блока:

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

Если блоку добавить JavaScript-функциональность (наприемр, клик по логотипу будет вызывать дополнительное действие), файл с JavaScript-реализацией будет создан по тем же правилам:
  * в отдельном файле;
  * имя файла будет соответствовать имени блока с расширением `.js`;
  * файл реализации будет находится в директории блока `logo/`.

JavaScript-реализация:

```js
$('.logo').on('click', doSomething);
```
Структура файоловой системы:

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
    logo.js         # Динамическое поведение блока в браузере
```

Возможность следовать всем принципам БЭМ в JavaScript обеспечивает декларативный стиль.

### Зачем писать JavaScript по БЭМ

JavaScript можно и не писать по БЭМ-принципам, а остановиться только на CSS. Но тогда ваш БЭМ-проект не получит следующих возможностей:

JavaScript, написанный по БЭМ, позволяет реализовать компонентный подход в полной мере.
В зависимости от того, какие правила вы решите применять к JavaScript-коду вашего проекта, вы сможете получить:

Чтобы в полной мере использовать компонентный подход, реализованный в БЭМ. Который в свою очередь позволяет: создавать независимые компоненты - блоки, повторно использовать, переносить блоки, получать расширяемую устойчивую систему, облегчить навигацию по проекту, облегчить рефакторинг за счет несвязанности компонент, облегчить и ускорить разработку за счет возможности разрабатывать помодульно.


Плюсы для разработчика
* Работать с одними и теми же сущностями (блоками, элементами, модификаторами) не только над внешним видом компонент, но и над их поведением.
* Называть все сущности одинаково во всех технологиях (JavaScript, CSS, HTML).
* Получать независимые компоненты интерфейса, которые можно повторно использовать, переносить из проекта в проект.
* Консистентно организовывать файловую систему проекта, быстро ориентироваться в проекте и находить нужные файлы.
* Разделять реализацию блоков по уровням переопределения не только в CSS, но и в JavaScript.
* Подключать только нужную реализацию блока в проект.

## JavaScript по БЭМ

В БЭМ-методологии в JavaScript используются основные принципы объектно-ориентированного программирования.

JavaScript-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретных интерфейсах каждый блок может быть представлен несколькими экземплярами. Экземпляр блока реализует функциональность своего класса и имеет собственное, независимое состояние, которое можно изменять (переопределять) или дополнять (доопределять).

### В терминах парадигмы ООП

#### Классы и объекты

* блок — это класс;
* экземпляр блока — это экземпляр класса (объект).

#### Инкапсуляция

В соответствии с ООП, вся функциональность блока реализуется модульно в методах класса (=блока).

#### Наследование
Поведение блока программируется в декларативном стиле в виде утверждений: набор условий — реакция блока. Это позволяет использовать уровни переопределения по аналогии с CSS.

Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.







Декларация блока




Блоки с DOM-представлением

Объявление нового блока без родителя

Чтобы задекларировать новый JS-блок с DOM-представлением (привязанный к HTML-элементу), нужно воспользоваться методом decl ym-модуля i-bem__dom.

Блоки без DOM-представления

Для декларации блоков без DOM-представления служит метод decl ym-модуля i-bem.

Метод принимает те же параметры, что и метод decl модуля i-bem__dom:




Наследование блока

Одна и та же функциональность может быть востребована в нескольких блоках проекта. Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX, или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде, общую функциональность можно инкапсулировать в виде модулей, а затем добавлять к блокам.

Наследование позволяет повторно использовать функциональность блока, расширяя ее новой логикой. В i-bem.js доступно несколько механизмов наследования. Выбор конкретного механизма зависит от специфики создаваемого блока.


Доопределение блока

Чтобы создать вариант уже существующего блока с измененной или дополненной функциональностью, можно доопределить базовый блок на уровне переопределения проекта.

Для этого в проекте создается декларация нового блока с тем же именем, что и у базового. В результате блоку будет доступна вся функциональностью базового. Реализация одноименных методов и модификаторов, при этом, будет взята из новой декларации.




Добавление модификатора к блоку

В соответствии с БЭМ-методологией состояния блока должны описываться модификаторами. Поэтому чтобы расширить функциональность блока часто нужно реализовать поддержку новых модификаторов.




Блоки-миксы

В i-bem.js для добавления востребованной функциональности к блокам используется специальный тип блоков – блоки-миксы. Главная особенность блоков-миксов состоит в том, что они не участвуют в цепочке наследования. Это позволяет примешивать реализованную в них функциональность к другим блокам без риска нарушить их связи с родительскими блоками (this.__base).







Декларация триггеров

Триггеры, выполняемые при установке модификаторов, описываются в декларации блока. Для этого в хэше методов экземпляра блока зарезервированы свойства:

beforeSetMod — триггеры, вызываемые до установки модификаторов блока;
beforeElemSetMod — триггеры, вызываемые до установки модификаторов элементов;
onSetMod — триггеры, вызываемые после установки модификаторов блока;
onElemSetMod — триггеры, вызываемые после установки модификаторов элементов блока.






Состояния блока

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику изменений, происходящих в нем, как набор состояний блока. Тогда поведение блока определяется триггерами — callback-функциями, которые выполняются при переходе блока из одного состояния в другое.

Это позволяет писать код блока в декларативном стиле как набор утверждений вида: описание состояния — действия, выполняемые при переходе в данное состояние.


Модификаторы

Согласно БЭМ-методологии, состояние блока и его элементов описывается модификаторами.

Модификатор указывает, в каком из возможных состояний находится блок. Модификатор представляет собой пару: имя и значение. Список допустимых значений модификатора описывает набор состояний блока. Например, для описания размеров блока можно использовать модификатор size с допустимыми значениями s, m и l.

Простой модификатор — частный случай, когда важно только наличие или отсутствие модификатора у блока, а его значение несущественно. Например, модификатор, описывающий состояние «отключен»: disabled. Модификатор с неуказанным значением i-bem.js интерпретирует как булев и автоматически присваивает ему значение true.

Каждому блоку можно установить один или несколько модификаторов. Блок может не иметь модификаторов. Список допустимых модификаторов и их значений определяет разработчик блока.

Модификаторы устанавливаются при инициализации экземпляра блока (если модификаторы и их значения указаны в атрибуте class соответствующего HTML-элемента).

Модификаторы могут изменяться как в процессе работы блока (например, как реакция на DOM-события блока), там и по запросу из других блоков (см. раздел Взаимодействие блоков).

При установке, удалении и изменении значений модификаторов, выполняются триггеры.






JavaScript-компоненты в i-bem.js служат для «оживления» HTML-элементов страницы.

























Она служит для «оживления» блоков и обеспечивает взаимодействие между отдельными блоками на странице, между блоком и его элементами, а также реакцию на изменения модификатора блока.

**Пример**

* `my-block.css` — внешний вид блока;
* `my-block.tmpl` — шаблоны для генерации HTML-представления блока;
* `my-block.js` — динамическое поведение блока в браузере.

JavaScript, на равне с другими технологиями, подчиняется основным правилам БЭМ-методологии:
  * единые термины блоков, элементов и модификтаоров;
  * единые правила именования;
  * поблочная реализация функциональности;
  * разделение по файлам блоков.

**Пример**

Блок логотип (`logo`) реализован в двух технологиях: шаблоне и стилях.

HTML-реализация:

```html
<a class="logo" href="/">Ваша крутая компания</a>
```
CSS-реализация:

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logok.png) no-repeat;
}
```

По [правилам организации файловой системы БЭМ-проекта](../filesystem/filesystem.ru.md) шаблон и стили находятся в директории блока:

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

Если блоку добавить JavaScript-функциональность (наприемр, клик по логотипу будет вызывать дополнительное действие), то файл с JavaScript-реализацией будет создан по тем же правилам:
  * JavaScript-реализация находится в отдельном файле.
  * Имя файла соответствует имени блока с расширением `.js`.
  * Файл реализации находится в директории блока `logo/`.

```js
$('.logo').on('click', doSomething);
```

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
    logo.js         # Динамическое поведение блока в браузере
```

JavaScript, написанный по принципам БЭМ, обеспечивает возможность использования компоенентного подхода и на уровне поведения блоков.

Возможность следовать всем принципам БЭМ и в JavaScript дает декларативный стиль.




JavaScript используется для «оживления» блоков и рассматривается в БЭМ-методологии как одна из технологий реализации блока. Поэтому к JavaScript применются все те же правлиа, которые используются для других технологий, в частности CSS.




* работа в терминах блоков, элементов и модификтаоров
* поблочная реализация функциональности
* разделение по отдельным файлам
* единые правила именования

**Пример**

Блок логотип (`logo`) реализован в двух технологиях: шаблоне и стилях.

```html
<a class="logo" href="/">Ваша крутая компания</a>
```
и

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logok.png) no-repeat;
}
```

По [правилам организации файловой системы БЭМ-проекта](../filesystem/filesystem.ru.md) шаблон и стили находятся в директории блока.

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

Если блоку добавить JavaScript-функциональность (наприемр, клик по логотипу будет вызывать дополнительное действие), то файл с JavaScript-реализацией будет создан по тем же правилам:
  * JavaScript-реализация находится в отдельном файле.
  * Имя файла соответствует имени блока с расширением `.js`.
  * Файл реализации находится в директории блока `logo/`.

```js
$('.logo').on('click', doSomething);
```

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
    logo.js         # Динамическое поведение блока в браузере
```













БЭМ — это про компонентный подход к разработке в целом. Интерфейс БЭМ-проекта строится из отдельных компонентов ([блоков](../definitions/definitions.ru.md#block)), у которых могут быть [элементы](../definitions/definitions.ru.md#element). Блоки и элементы могут иметь состояния или особенности, которые описываются [модификаторами](..definitions/definitions.ru.md#modifier).

Компонентный подход в БЭМ предполагает, что [реализация блока](../definitions/definitions.ru.md#Реализация-блока), элемента или модификатора обеспечивается различными [технологиями](../definitions/definitions.ru.md#Технология-реализации). Блок содержит набор [файлов технологий](../filesystem/filesystem.ru.md#Реализация-блока-разделяется-на-отдельные-файлы), составляющих различные аспекты его реализации.

Рассмотрим на примере логотипа. В нашем случае блок логотип (`logo`) реализован в двух технологиях: шаблоне и стилях.

```hml
<a class="logo" href="/">Ваша крутая компания</a>
```
и

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logo.png) no-repeat;
}
```

По [правилам организации файловой системы БЭМ-проекта](../filesystem/filesystem.ru.md) шаблон и стили находятся в директории блока.

```fil
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

К [реализации](../definitions/definitions.ru.md#Реализация-блока) блока могут относится, например, картинки, тесты, документация, примеры использования. Каждая технология находится в отдельном файле и хранится в директории блока.

Блоки, которым требуется JavaScript для работы, создаются также: файл с JavaScript-реализацией помещается в директорию блока.

В качестве примера рассмотрим тот же блок `logo`, но с JavaScript-функциональностью — клик по логотипу вызывает дополнительное действие:

```js
$('.logo').on('click', doSomething);
```

```
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
    logo.js         # Динамическое поведение блока в браузере
```

### Зачем писать JavaScript по БЭМ

ЯВНО НАПИСАТЬ ПРО ТО ЧТО МЫ СО ВСЕМИ ТЕХНОЛОГИЯМИ ТАК ПОСТУПАЕМ

Применение компонентного подхода к JavaScript в БЭМ-методологии позволяет:

ВСЕ ЭТО ОПЦИОНАЛЬНО В ЗАВИСИМОСТИ ОТ ПОЛНОТЫ РЕАЛИЗАЦИИ МОЖНО ПОЛУЧИТЬ

* Работать с одними и теми же сущностями (блоками, элементами, модификаторами) не только над внешним видом компонент, но и над их поведением.
* Получить компоненты интерфейса, которые можно повторно использовать, переносить из проекта в проект.

КОНСИСТЕНТНО - ФАЙЛОВАЯ СИСТЕМА, ПОИСК СЫРЦОВ,

Если реализовать все идеи методологии то получится возможными переопредлять и доопределять комппнеты слоями с помощью уровней переопределия по аналогии с CSS

















Давайте вспомним о чем говорит методология:1. Мы перестаем мыслить тегами. Вместо этого у нас появляются блоки.2. Блоки могут иметь элементы.Состояние блоков и элементов может меняться с помощью модификаторов. Под состоянием нужно понимать как внешнийвид (шаблоны, css), так и поведение (js). Т.о. у разработчиков, отвечающих за разные технологии, оказывается единаяпредметная область.
14. Благодаря разделению на уровни у нас появляется возможность реализовать библиотеку блоков и использовать сборку.Как это работает в CSS понятно: стили из библиотеки доопределяются и переопределяются стилями проекта, страницы илитемы оформления.По БЭМ-методологии JS имеет все те же возможности.
15. Получается эдакий коктейль, где каждый уровень соответствующим образом переопределяет поведение ;)
16. 16 i-bem.js ООП в полный рост — классы и экземпляры — полиморфизм и наследование за счет уровней переопределения — инкапсуляция Декларативный подход и предметная область БЭМОбъект = Блок из предметной области БЭМ (нет классов и ДОМ-дерева)Все одинаковые блоки на странице - это класс, а каждый конкретный блок - это экземпляр данного класса.Полиморфизм и наследование за счет уровней переопределения и модификаторовИнкапсуляция – за счет получения больших составных блоков на основе нескольких маленькихДекларативный подход (как в css)
17. Все эти возможности мы рассмотрим на примере блока из Бутстрапа
18. К сожалению в рамках доклада мы не успеем рассмотреть больше, чем один блок, поэтому я выбрал карусель – онаперекликается с предыдущим докладом, является достаточно самостоятельным проектом и как раз позволит за 15 минутзатронуть основные возможности i-bem.jsИтак, всем знакомая карусель состоит из контейнера какой-то ширины, каждый из вложенных элементов которогопоследовательно занимает всю ширину родителя, позволяет реализовать слайд-шоу и переключать «кадры» вручную.
19. 19 Библиотека bootstrap-bl github.com/tadatuta/ bootstrap-blПо ссылке находится репозиторий на гитхабе, где я с помощью короткого баш-скрипта переименовал блоки из Бутстрападля соответствия БЭМ-нотации. Скрипт находится в этом же репозитории.После перевода блоков в БЭМ-нотацию, оригинальная js-реализация по-прежнему осталась работоспособной. Но мы свами напишем реализацию на i-bem.js для блока карусели. less остался без изменений и отлично собирается с помощьюbem-toolsВажно понимать, что блоки из Бутстрапа – это лишь уровень переопределения в терминах БЭМ и методология гораздошире, чем просто способ реиспользования кода.
20. 20 carousel.js BEM.DOM.decl(carousel, { /* Динамические свойства и методы */ },{ /* Статические свойства и методы */ })Аналогично css - указываем правила поведения блоков, которые срабатывают при наступлении нужных условий.Для реализации карусели нам понадобятся методы: cycle, etc.
21. 21 BEM.DOM.decl(carousel, { onSetMod : { mod : { val : function() { // Реакция на установку // значения модификатора } } } })чтобы навеситься на кнопки
22. 22 i-bem.js — JSDoc clck.ru/1262jКаждый метод i-bem.js сопровождается подробным описанием в jsdoc, так что можно легко разобраться даже незаглядывая в документацию.
23. 23 /** * @protected * @param {jQuery|String} [elem] элемент * @param {String} event имя события * @param {Function} fn функция-обработчик, будет выполнена в контексте блока * @returns {BEM} */ bindTo : function(elem, event, fn)Добавляет обработчик события на основные DOM-элементы блока или его вложенные элементы
24. 24 /** * @protected * @param {String} names имя (или через пробел имена) вложенных элементов * @param {String} [modName] имя модификатора * @param {String} [modVal] значение модификатора * @returns {jQuery} DOM-элементы */ elem : function( names, modName, modVal)Поиск вложенных в блок элементов (результат кэшируется)
25. 25 /** * @protected * @param {Object} [elem] вложенный элемент * @param {String} modName имя модификатора * @param {String} [modVal] значение модификатора * @returns {Boolean} */ hasMod : function( elem, modName, modVal)Проверяет наличие модификатора у блока/вложенного элемента
26. 26 /** * @protected * @param {Object} [elem] вложенный элемент * @param {String} modName имя модификатора * @param {String} modVal значение модификатора * @returns {BEM} */ setMod : function(elem, modName, modVal)Устанавливает модификатор у блока/вложенного элемента
27. /** 27 * @protected * @param {Stringring|jQuery} [ctx=this.domElem] элемент, на котором проходит поиск * @param {String} names имя (или через пробел имена) вложенных элементов * @param {String} [modName] имя модификатора * @param {String} [modVal] значение модификатора * @returns {jQuery} DOM-элементы */ findElem : function( ctx, names, modName, modVal)Поиск вложенных в блок элементов (результат не кэшируется)
28. 28 /** * @protected * @param {String} e имя события * @param {Object} [data] дополнительные данные * @returns {BEM} */ trigger : function(e, data)Запускает обработчики события у блока и обработчики live-событийtrigger — это БЭМ событие
29. 29 /** * @protected * @param {Object} [elem] вложенный элемент * @param {String} modName имя модификатора * @returns {BEM} */ delMod : function(elem, modName)Удаляет модификатор у блока/вложенного элемента
30. 30 В результате — Рассмотрели основные возможности блока i- bem.js — Реализовали карусель из Bootstrap в БЭМ- терминах — Переопределили javascript из библиотек блоков на уровне переопределения проекта— Рассмотрели основные возможности блока i-bem.js— Реализовали карусель из Twitter Bootstrap в БЭМ-терминах— Научились переопределять javascript библиотек на уровне переопределения проекта




















## Как писать JavaScript по БЭМ

Разделение CSS на отдельные файлы больше не вызывает споров, так как компонентный подход, помимо БЭМ, реализован во многих продуктах, таких как Polymer или стандарт Web Components.

Идея разделения JavaScript-кода ВЫЗЫВАЕТ ряд вопросов. ОсновнЫЕ ВОПРОСЫ

ВЗАИМОДЕЙСТВИЕ БЛОКЛВ ДРУГ С ДРУГОМ
РЕАКЦИЯ НА ИЗМЕНЕНИЕ МОДИФИКАТОРА
ВЗАИМОДЕЙСТВИЕ БЛОКА СО СВОИМИ ЭЛЕМЕНТАМИ

 — как писать независимый JavaScript для каждого блока, если блоки взаимодействуют друг с другом на уровне JavaScript.

ПОДВОДКА

Рассмотрим различные способы создания формы с помощью JavaScript, чтобы понять, как писать JS-реализацию отдельно для каждого блока и какие преимущества это дает.

В качестве примера возьмем форму (`form`), в которой:
* перед отправкой формы осуществляется проверка введенного значения;
* в случае ошибки показывается всплывающее окно (`popup`) с предупреждением.

```html
<form class="form" action="/">
    <input class="input" name="email">
    <input class="button" type="submit">
    <div class="popup">Пожалуйста, введите корректный email</div>
</form>
```

```css
.popup {
    display: none;
}

.popup_visible {
    display: block;
}
```

Пример реализации формы в стиле jQuery:

```js
$('.button').on('click', function(e) {
    if (!/\S+@\S+\.\S+/.test($('.input').val())) {
        $('.popup').addClass('popup_visible');
        return false;
    }
});
```

Достаточно написать шесть строк, чтобы форма начала работать. Но у такого кода есть ряд недостатков:

* Сильная связанность кода: кнопка «знает» про поле ввода (`input`) и всплывающее окно (`popup`). Кроме того, кнопка находится внутри формы (`form`).
* Проблемы при отладке кода: если какой-либо из компонентов формы исчезнет или добавится еще одно поле (`input`), код перестанет работать.
* Проблемы при повторном использовании кода: повторное использование кнопки потребует наличия всех компонентов формы с такими же классами. При этом, для правильной работы необходимо гарантировать, что на странице кнопка будет уникальна.

В результате, простой и короткий код вызовет проблемы в поддержке. Форму можно будет использовать повторно, только если создается точная копия проекта.

Попробуем изменить код, чтобы избавиться от части перечисленных проблем:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.input', this).val())) return true;
    e.preventDefault();
    $('.popup', this).addClass('popup_visible');
});
```

Теперь компоненты внутри формы ничего не знают о существовании друг друга. Это означает, что они стали независимыми. Кнопку можно перенести в другой проект без формы, поля ввода и всплывающего окна.

Все селекторы вынесены за рамки контекста формы: теперь за пределами формы можно добавлять любое количество новых полей ввода, всплывающих окон и кнопок.

Оставшиеся недостатки:

* Добавление еще одного поля потребует изменений в коде.
* Чтобы гарантировать перекрытие всплывающим окном всех других компонентов на странице, необходимо указать его в самом конце DOM-дерева, перед закрывающим тегом `</body>`.

Использование кода все еще можно сделать удобнее. Для этого можно вынести всплывающее окно из формы и добавить еще одно поле. Сами поля необходимо [смиксовать](../definitions/definitions.ru.md#mix) с элементами формы.

Микс — это объединение нескольких блоков на одном DOM-узле.

```html
<form class="form" action="/">
    <input class="input form__login" name="login">
    <input class="input form__email" name="email">
    <input class="button" type="submit">
</form>
<div class="popup form__hint">Пожалуйста, введите корректный email</div>
```

Теперь код выглядит так:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    $('.form__hint').addClass('popup_visible');
});
```

Такой код решает все описанные выше проблемы. Но добавляет новую: если на странице будет несколько форм, как каждая из них найдет свое всплывающее окно?

Существует несколько решений:

* Использовать паттерн MVC и обеспечить проверку формы на уровне модели.
* Реализовать механизм, который позволит выражать один блок на нескольких DOM-нодах. Схематично он может выглядеть так:

  ```html
  <form class="form" action="/" data-id="1">
      <input class="input form__login" name="login">
      <input class="input form__email" name="email">
      <input class="button" type="submit">
  </form>
  <div class="popup form form__hint" data-id="1">Пожалуйста, введите корректный email</div>
  ```

  Что сделано:
  * Форме добавлен data-атрибут с идентификатором.
  * К всплывающему окну помимо элемента примиксована форма с таким же идентификатором.

  Следующим шагом необходимо указать, что нужен элемент `hint` именно этого блока `form`:

  ```js
  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      $('.form__hint').filter('.form[data-id=' + $(this).data('id') + ']').addClass('popup_visible');
  });
  ```
* Воспользоваться паттерном проектирования «Посредник».
  Такое решение сохраняет независимость блоков и позволяет не вносить изменения в DOM.

  Компоненты формы ничего не знают друг о друге, но знают о существовании посредника. Все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

  Чтобы максимально упростить пример, сделаем таким посредником `body`. Он может обеспечить обмен сообщениями, так как всегда присутствует в коде и может знать обо всех компонентах на странице.

  ```html
  <body class="page">
      <form class="form" action="/">
          <input class="input form__login" name="login">
          <input class="input form__email" name="email">
          <input class="button" type="submit">
      </form>
      <div class="popup"></div>
  </body>
  ```

  ```js
  var page = $('.page');

  page.on('error', function(e, data) {
      $('.popup')
          .text(data)
          .addClass('popup_visible');
  });

  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      page.trigger('error', 'Ошибка валидации');
  });
  ```

  Теперь в случае ошибки, форма сообщит об этом посреднику — `page`. Все компоненты, которые должны реагировать на это событие, могут «подписаться» на него через `page.on()`.


Разделение JavaScript-реализации на файлы помогает сохранять независимость блоков, упрощает отладку и повторное использование кода.

## Декларативный JavaScript по БЭМ

В БЭМ-проекте интерфейс строится из **блоков** и их **элементов**. Над ними можно совершать различные действия с помощью **модификаторов**.

Если запилите вот так и так, то получите ништяки

есть задача показывать и скрывать попап


JS по БЭМ -

про то что есть блоки и мод




Одно из ключевых понятий БЭМ-методологии — [уровни переопределения](../definitions/definitions.ru.md#Уровень-переопределния). Они позволяют дополнять и расширять поведение блоков от проекта к проекту.

> Если в вашем проекте все блоки находятся на одном уровне переопределения, ограничений по использованию выбранного фреймворка (например, jQuery) не существует.

Декларативный подход в JavaScript в БЭМ позволяет использовать уровни переопределения. То, что раньше было реализовано только для CSS, теперь доступно и для JavaScript. При расширении функциональности уже существующего блока, разработчик всегда имеет доступ к поведению, определенному предыдущим уровнем. То есть методы можно не только полностью перезаписывать, но и дополнять недостающее поведение блока.

Кроме наследования по уровням переопределения существует возможность явно отнаследовать один блок от другого.

> В БЭМ-платформе реализован фреймворк `i-bem`, который позволяет использовать все преимущества БЭМ-методологии.
  [Подробная документация](https://ru.bem.info/technology/i-bem/v2/i-bem-js/).
