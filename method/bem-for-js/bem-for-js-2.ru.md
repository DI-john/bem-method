# JavaScript по БЭМ

В БЭМ-методологии JavaScript используется для «оживления» веб-страницы и рассматривается как одна из [технологий реализации](../definitions/definitions.ru.md#Технология-реализации) блока.

На ровне с другими технологиями (CSS, HTML, шаблоны), в работе с JavaScript могут соблюдаться следующие принципы БЭМ-методологии:
  * [Единая предметная область](#Единая-предметная-область) — использование блоков, элементов и модификаторов, названныех по общим [правилам именования БЭМ-сущностей](../naming-convention/naming-convention.ru.md).
  * [Разделение кода на части](#Разделение-кода-на-части) и одинаковые [правила организации файловой структуры БЭМ-проекта](../filesystem/filesystem.ru.md).
  * Использование уровней переопределния и сборки.

## Единая предметная область

В web-технологиях финальный продукт (например, веб-страница) состоит из разных технологий (например, HTML, CSS, JS). В БЭМ для работы во всех технологиях используются единые термины и подходы к реализации.

Так, напрмер, JavaScript-реализации блоков не оперируют понятиями DOM-элементов, а используют следующий уровень абстрации - [БЭМ-дерево](../key-concepts/key-concepts.ru.md#БЭМ-дерево) — и работают в терминах блоков, элементов и модификаторов. В шаблонах и CSS модификаторы выражают внешний вид блока или его элемента. Логика работы блока или элемента в JavaScript также выражается с помощью **модификаторов** и описывается как набор состояний.

Применение единых понятий во всех технологийях реализации позволяет реализовать в JavaScript различные хелперы для работы с компонентами и отказаться от жесткого кодирования имен блоков и разделителей. Такой подход дает возможность, например, найти внутри блока все элементы с определенным именем и выставить им модификатор, проверить его значение.

**Пример**

Рассмотрим пример всплывающего окна (`popup`). Показывать всплывающее окно можно различными способами, например:

Можно воспользоваться распространенным решением и добавлять соответствующий класс. Такой способ не всегда удобен, так как необходимо жестко прописывать имя блока в коде.

```js
document.querySelector('.button')
  .addEventListener('click', function() {
    document.querySelector('.popup').classList.toggle('popup_visible');
},
false);
```

А можно воспользоваться принципами БЭМ и оперировать не классами, а блоками, элементами и модификаторами.

```js
block('button').click(function() {
    block('popup').toggleMod('visible');
});
```
В таком случае поиск компонента осуществляется не по классу, а по блоку, который в проекте может выражаться тегом, классом, атрибутом и т.д. Отображение всплывающего окна (перевод блока `popup` в состояние `visible`) также осуществляется не по классу, а с помощью модификатора.

Использование понятий блоков, элементов и модификаторов дает возможность на более высоком уровне взаимодействовать с компонентами и получать хелперы для работы с ними в единой предметной области.

> все БЭМ-примеры в документе созданы на вымышленном фреймворке, а реальную реализацию смотри в i-bem

### Работа с модификаторами

Модификаторы могут задавать блокам определенные состояния. Логика работы блока реализуется в JavaScript и описывается с помощью состояний. Перевод блока в другое состояние может производиться при помощи установки/снятия модификатора. Например, чтобы отметить чекбокс, блоку `checkbox` нужно установить модификатор `checked` в значение `true`.

Модификаторы нельзя устанавливать, напрямую меняя CSS-класс на соответствующем DOM-узле. Для корректной работы JavaScript все манипуляции с модификаторами должны производиться при помощи методов-хелперов.

#### Реакция на изменение модификаторов

Переход блока из одного состояния в другое часто вызывает изменения в его внешнем виде. Если в проекте в CSS внешний вид блока задается с помощью модификатора, то изменение состояния блока, вызванное тем же модификатором, автоматически применит все необходимые стили.

Изменение модификатора создает событие, которое можно использовать для работы с блоком.

В БЭМ поведение на установку/снятие модификатора описывается [декларативно](#Декларативный-стиль). Так, например, если в CSS во время исполнения появляется какой-то дополнительный класс (модификатор), то все свойства этого модификатора автоматически применяются к DOM-узлу, на который этот класс установлен. В JavaScript происходит то же самое: если появляется модификатор (добавляется новый класс к DOM-узлу), то вся функциональность, свойственная этому модификатору, применяется. Если модификатор исчезает, функциональность отключается.

Чтобы динамически изменять состояния блоков и элементов, используются специальные методы для установки и снятия модификаторов.

**Пример**

Рассмотрим форму отправки сообщения. Должно выполняться условие: если введен неправильный e-mail, кнопка отправки (блок `button`) становится недоступна (получает модификатор `button_disabled`).

Можно жестко прописать все условия в коде и постоянно выполнять проверку, а можно задекларировать поведение блока и получить возможность перекрывать каждый модификатор отдельно на новом уровне переопределения. В декларации можно указать, как блок или элемент должен отреагировать на изменение модификатора.

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Такой подход дает возможность:
* Реагировать на модификатор, независимо от того, как он был установлен: через JavaScript API: `block('button').setMod('focused')` или пользователь установил фокус курсором.
* Аналогично реагировать на удаления фокуса, так как изменение состояния выражается модификаторами, то есть появлением/снятием классов на DOM-узле.
* Определять каждому состоянию свой внешний вид, добавив стили модификатору.
* Изменять или полностью перекрывать поведение блока с помощью [уровней переопределения](#Работа-с-уровнями-переопределения).

## Разделение кода на части

JavaScript — это одна из технологий реализации блока, поэтому к ней могут применяются основные принципы организации и хранения кода в БЭМ-методологии:
  * разделение кода на отдельные части — логика работы каждого блока, его опционального элемента и модификатора описывается в отдельном файле;
  * JavaScript-файлы для каждого компонента хранятся в соответствии с [правилами организации файловой структуры](../filesystem/filesystem.ru.md) БЭМ-проекта.

**Пример**

Рассмотрим пример логотипа (блок `logo`), реализованного в двух технологиях: шаблоне и стилях.

HTML-реализация блока:

```html
<a class="logo" href="/">Ваша крутая компания</a>
```
CSS-реализация блока:

```css
.logo {
    width: 150px;
    height: 100px;
}
```
Блок `logo` в файловой структуре проекта:

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

Добавим блоку `logo` JavaScript-функциональность: теперь нажатие на логотип вызывает какое-то действие. Согласно БЭМ-методологии новое поведение блока `logo` будет реализовано следующим образом:
  * в отдельном файле;
  * имя файла будет соответствовать имени блока с расширением `.js`;
  * файл `logo.js` будет находится в директории блока `logo/`.

JavaScript-реализация блока:

```js
document.querySelector('.logo').addEventListener('click', doSomething, false);
```

Файл `logo.js` в файловой структуре блока:

```files
logo/
    logo.css         # Внешний вид блока
    logo.tmpl        # Шаблоны для генерации HTML-представления блока
    logo.js          # Динамическое поведение блока в браузере
```

Разделение кода на части и строгая организация файловой системы проекта позволяет не только облегчить навигацию по проекту и повторное использование или перенос компонентов, но и работать с уровнями переопределния для JavaScript и использовать сборку.

## Работа с уровнями переопределения

В описании БЭМ-методологии приведено [много примеров](../filesystem/filesystem.ru.md#Примеры-использования-уровней-переопределения), где конечная CSS-реализация блока собирается с разных уровней переопределения. Применение принципов БЭМ-методологии к JavaScript позволяет аналогично CSS разделять поведение блоков по разным уроням:
  * реализовывать новую функциональность блока на другом уровне переопределения, сохраняя предыдущее поведение блока, наследовать и дополнять его (делать super call);
  * полностью перекрывать поведение блока (переопределять);
  * добавлять новые блоки с новой функциональностью, которых не было на предыдущих уровнях.

С помощью уровней переопределения можно создать JavaScript-библиотеку блоков, изменять ее на проектном уровне и использовать сборку, включая в проект только необходимое поведение блоков.

**Пример**

Вернемся к примеру формы отправки сообщения:

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Запись с стиле БЭМ позволяет:

* Полностью перекрывать поведение блока на другом уровне переопределения.

  ```js
  block('button').onSetMod({
      focused: {
          true: this.someCustomOnFocused
      }
  });
  ```
* Добавлять или частично измениять поведение блока на другом уровне переопределения.

  ```js
  block('button').onSetMod({
      focused: {
          true: function() {
              this.__base.apply(this, arguments);
              this.someCustomOnFocused();
          }
      }
  });
  ```

> Для работы с уровнями переопределения в БЭМ принято использовать специализированный фреймворк, например, i-bem.js.


## Особенности реализации JavaScript по БЭМ-методологии

* [Декларативный стиль](#Декларативный-стиль)
* [Принципы ООП в JavaScript по БЭМ](#Принципы-ООП-в-javascript-по-БЭМ)
* [Представление динамических блоков в DOM](#Представление-динамических-блоков-в-dom)
* [Взаимодействие блоков](#Взаимодействие-блоков)
* [Взаимодействие блока с его элементами](#Взаимодействие-блока-с-его-элементами)

### Декларативный стиль

Декларативность JavaScript в БЭМ-проекте проявляется в следующем:

* Поведение каждого блока описывается независимо. В БЭМ JavaScript-код блока принято называть **декларацией**.
* Состояния блока описываются декларативно. Это позволяет при [изменении состояний](#Реакция-на-изменение-модификаторов) автоматически вызывать код, который задекларирован для этого состояния.
* Логика работы блока описывается как набор действий и условий, при которых эти действия необходимо выполнять. Это позволяет разделять функциональность блока на отдельные части и использовать [уровни переопределения](#Работа-с-уровнями-переопределения).

### Принципы ООП в JavaScript по БЭМ

В БЭМ-методологии к JavaScript применяются основные принципы объектно-ориентированного программирования.

#### Инкапсуляция

В БЭМ-методологии JavaScript-реализация одного блока отделена от другого.

Декларация блока позволяет скрыть его внутреннюю реализацию и предоставить API для [взаимодействия с другими блоками](#Взаимодействие-блоков).
Все элементы блока являются его внутренней реализацией, поэтому [обращаться к элементам можно только через API самого блока](#Взаимодействие-блока-с-его-элементами).

#### Наследование

Декларативное описание поведения блоков позволяет использовать методы базового блока внутри производного, наследовать их. Новый блок получит все свойства и методы базового.

Также можно создавать цепочки наследования – блок наследуется от другого, который, в свою очередь, наследуется от третьего и т.д.

> Примеры реализации доступны в i-bem.js.

### Представление динамических блоков в DOM

Блокам с JavaScript-реализацией могут соответствовать узлы в HTML. В этом случае говорится о том, что **блоки имеют DOM-представление**.

В простейшем случае блок соответствует DOM-узлу один к одному. DOM-узел и блок — это не всегда одно и тоже. Можно разместить несколько блоков на одном DOM-узле (это называется [микс](../key-concepts/key-concepts.ru.md#Микс)), а также реализовать один блок на нескольких DOM-узлах.

> Примеры реализации доступны в i-bem.js.

Существуют **блоки без DOM-представления**. В JavaScript они представлены в виде объектов, имеющих свои методы.

### Взаимодействие блоков

БЭМ-методология предполагает работу с независимыми блоками. Однако на практике полная независимость блоков недостижима.

Блоки могут взаимодействовать друг с другом с помощью:

* Подписки на события других экземпляров блоков.
* Подписки на изменения модификаторов.
* Непосредственного вызова методов других экземпляров блоков или статических методов класса другого блока.
* Любых шаблонов взаимодействия, например, канала событий. Все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

> Примеры реализации смотри в i-bem.js

БЭМ-методология рекомендует выстраивать взаимодействие между блоками в иерархическом порядке в соответствии с их расположением в DOM-дереве. Вложенный блок не должен ничего знать о родительском блоке, так как это нарушает принцип независимости блоков.

### Взаимодействие блока с его элементами

Элемент - это внутренняя реализация блока.
В БЭМ-методологии принято реализовывать дополнительные хелперы блока для работы с его элементами. Обращение напрямую к элементы другого блока невозможно. Взаимодействие происходить только только через API блока, которому принадлежит данный элемент.

