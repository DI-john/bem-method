БЭМ и JavaScript

БЭМ — это про компонентный подход к разработке в целом. Интерфейс БЭМ-проекта строится из отдельных компонентов ([блоков](../definitions/definitions.ru.md#block)), у которых могут быть [элементы](../definitions/definitions.ru.md#element). Блоки и элементы могут иметь состояния или особенности, которые описываются [модификаторами](..definitions/definitions.ru.md#modifier).

Компонентный подход в БЭМ предполагает, что [реализация блока](../definitions/definitions.ru.md#Реализация-блока), элемента или модификатора обеспечивается различными [технологиями](../definitions/definitions.ru.md#Технология-реализации). Блок содержит набор [файлов технологий](../filesystem/filesystem.ru.md#Реализация-блока-разделяется-на-отдельные-файлы), составляющих различные аспекты его реализации.

Рассмотрим на примере логотипа. В нашем случае блок логотип (`logo`) реализован в двух технологиях: шаблоне и стилях.

```hml
<a class="logo" href="/">Ваша крутая компания</a>
```
и

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logo.png) no-repeat;
}
```

По [правилам организации файловой системы БЭМ-проекта](../filesystem/filesystem.ru.md) шаблон и стили находятся в директории блока.

```
logo/
    logo.css        # Внешний вид блока
    logo.templ      # Шаблоны для генерации HTML-представления блока (расширение файла `templ` условно)
```

К реализации блока могут относится, например, картинки, тесты, документация, примеры использования, исходники. Каждая технология находится в отдельном файле и хранится в директории блока.

Блоки, которым требуется JavaScript для работы, создаются также: файл с JavaScript-реализацией помещается в директорию блока.

В качестве примера рассмотрим тот же блок `logo`, но с JavaScript-функциональностью — клик по логотипу вызывает дополнительное действие:

```js
$('.logo').on('click', doSomething);
```

```
logo/
    logo.css        # Внешний вид блока
    logo.templ      # Шаблоны для генерации HTML-представления блока (расширение файла `templ` условно)
    logo.js         # Динамическое поведение блока в браузере
```

### Зачем писать JavaScript по БЭМ

Применение компонентного подхода к JavaScript в БЭМ-методологии позволяет:

* Работать с одними и теми же сущностями (блоками, элементами, модификаторами) не только над внешним видом компонент, но и над их поведением.
* Получить условно-независимые блоки (компоненты интерфейса), которые можно повторно использовать, переносить из проекта в проект.
* Использовать [декларативный стиль](#Декларативный-javascript-по-БЭМ), который позволяет получить все преимущества БЭМ-методологии.


## Как писать JavaScript по БЭМ

Разделение CSS на отдельные файлы больше не вызывает споров, так как компонентный подход помимо БЭМ реализован во многих продуктах, таких как Polymer или стандарт Web Components.

Идея разделения JavaScript-кода на отдельные файлы достаточно нова. Поэтому появляется ряд вопросов. Основной — как писать независимый JavaScript для каждого блока или элемента, если блоки взаимодействуют друг с другом на уровне JavaScript.

Рассмотрим различные способы создания формы с помощью JavaScript, чтобы понять, как писать JS-реализацию отдельно для каждого блока и какие преимущества это дает.

В качестве примера возьмем форму (`form`), в которой:
* перед отправкой формы осуществляется проверка введенного значения;
* в случае ошибки показывается всплывающее окно (`popup`) с предупреждением.

```html
<form class="form" action="/">
    <input class="input" name="email">
    <input class="button" type="submit">
    <div class="popup">Пожалуйста, введите корректный email</div>
</form>
```

```css
.popup {
    display: none;
}

.popup_visible {
    display: block;
}
```

Пример реализации формы в стиле «old school»:

```js
$('.button').on('click', function(e) {
    if (!/\S+@\S+\.\S+/.test($('.input').val())) {
        $('.popup').addClass('popup_visible');
        return false;
    }
});
```

Достаточно написать шесть строк, чтобы форма начала работать. Но у такого кода есть ряд недостатков:

* Сильная связанность кода: кнопка «знает» про поле ввода (`input`) и всплывающее окно (`popup`). Кроме того, кнопка находится внутри формы (`form`).
* Проблемы при отладке кода: если какой-либо из компонентов формы исчезнет или добавится еще одно поле (`input`), код перестанет работать.
* Проблемы при повторном использовании кода: повторное использование кнопки потребует наличия всех компонентов формы с такими же классами. При этом, для правильной работы необходимо гарантировать, что на странице кнопка будет уникальна.

В результате, простой и короткий код вызовет проблемы в поддержке. Форму можно будет использовать повторно, только если создается точная копия проекта.

Попробуем изменить код, чтобы избавиться от части перечисленных проблем:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.input', this).val())) return true;
    e.preventDefault();
    $('.popup', this).addClass('popup_visible');
});
```

Теперь компоненты внутри формы ничего не знают о существовании друг друга. Это означает, что они стали независимыми. Кнопку можно перенести в другой проект без формы, поля ввода и всплывающего окна.

Все селекторы вынесены за рамки контекста формы: теперь за пределами формы можно добавлять любое количество новых полей ввода, всплывающих окон и кнопок.

Оставшиеся недостатки:

* Добавление еще одного поля потребует изменений в коде.
* Чтобы гарантировать перекрытие всплывающим окном всех других компонентов на странице, необходимо указать его в самом конце DOM-дерева, перед закрывающим тегом `</body>`.

Использование кода все еще можно сделать удобнее. Для этого можно вынести всплывающее окно из формы и добавить еще одно поле. Сами поля необходимо [смиксовать](../definitions/definitions.ru.md#mix) с элементами формы.

Микс — это объединение нескольких блоков на одном DOM-узле.

```html
<form class="form" action="/">
    <input class="input form__login" name="login">
    <input class="input form__email" name="email">
    <input class="button" type="submit">
</form>
<div class="popup form__hint">Пожалуйста, введите корректный email</div>
```

Теперь код выглядит так:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    $('.form__hint').addClass('popup_visible');
});
```

Такой код решает все описанные выше проблемы. Но добавляет новую: если на странице будет несколько форм, как каждая из них найдет свое всплывающее окно?

Существует несколько решений:

* Использовать паттерн MVC и обеспечить проверку формы на уровне модели.
* Реализовать механизм, который позволит выражать один блок на нескольких DOM-нодах. Схематично он может выглядеть так:

  ```html
  <form class="form" action="/" data-id="1">
      <input class="input form__login" name="login">
      <input class="input form__email" name="email">
      <input class="button" type="submit">
  </form>
  <div class="popup form form__hint" data-id="1">Пожалуйста, введите корректный email</div>
  ```

  Что сделано:
  * Форме добавлен data-атрибут с идентификатором.
  * К всплывающему окну помимо элемента примиксована форма с таким же идентификатором.

  Следующим шагом необходимо указать, что нужен элемент `hint` именно этого блока `form`:

  ```js
  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      $('.form__hint').filter('.form[data-id=' + $(this).data('id') + ']').addClass('popup_visible');
  });
  ```
* Воспользоваться паттерном проектирования «Посредник» в упрощенном виде.
  Такое решение сохраняет независимость блоков и позволяет не вносить изменения в DOM.

  Компоненты формы ничего не знают друг о друге, но знают о существовании посредника. Все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

  Чтобы максимально упростить пример, сделаем таким посредником `body`. Он может обеспечить обмен сообщениями, так как всегда присутствует в коде и знает о всех компонентах на странице.

  ```html
  <body class="page">
      <form class="form" action="/">
          <input class="input form__login" name="login">
          <input class="input form__email" name="email">
          <input class="button" type="submit">
      </form>
      <div class="popup"></div>
  </body>
  ```

  ```js
  var page = $('.page');

  page.on('error', function(e, data) {
      $('.popup')
          .text(data)
          .addClass('popup_visible');
  });

  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      page.trigger('error', 'Ошибка валидации');
  });
  ```

  Теперь в случае ошибки, форма сообщит об этом посреднику — `page`. Все компоненты, которые должны реагировать на это событие, могут «подписаться» на него через `page.on()`.


Разделение JavaScript-реализации на отдельные помогает сохранять независимость блоков, упрощает отладку и повторное использование кода.

## Декларативный JavaScript по БЭМ

В БЭМ-проекте интерфейс строится из **блоков** и их **элементов**. Над ними можно совершать различные действия с помощью **модификаторов**.

Ключевое понятие БЭМ-методологии — [уровни переопределения](../definitions/definitions.ru.md#Уровень-переопределния). Они позволяют дополнять и расширять поведение блоков от проекта к проекту.

> Если в вашем проекте все блоки находятся на одном уровне переопределения, ограничений по использованию выбранного фреймворка (например, JQuery) не существует.

Декларативный подход в JavaScript в БЭМ позволяет использовать уровни переопределения. То, что раньше было реализовано только для CSS, теперь доступно и для JavaScript. При расширении функциональности уже существующего блока, разработчик всегда имеет доступ к поведению, определенному предыдущим уровнем. То есть методы можно не только полностью перезаписывать, но и дополнять недостающее поведение блока.

Кроме наследования по уровням переопределения существует возможность явно отнаследовать один блок от другого.

> В БЭМ-платформе реализован фреймворк `i-bem`, который позволяет использовтаь все преимущества БЭМ-методологии.
  [Подробная документация](https://ru.bem.info/technology/i-bem/v2/i-bem-js/)
