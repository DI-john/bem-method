В БЭМ-методологии JavaScript используется для «оживления» веб-страницы и рассматривается как одна из [технологий реализации](../definitions/definitions.ru.md#Технология-реализации) блока. На ровне с другими технологиями (CSS, HTML, шаблоны), в работе с JavaScript можно соблюдать следующие принципы БЭМ-методологии:
  * использовать единые термины блоков, элементов и модификаторов;
  * формировать имена БЭМ-сущностей по общим [правилам именования в БЭМ](../naming-convention/naming-convention.ru.md);
  * хранить файлы с JavaScript-реализацией по [принципам организации файловой структуры БЭМ-проекта](../filesystem/filesystem.ru.md).

**Пример**

Рассмотрим пример логотипа (блок `logo`), реализованного в двух технологиях: шаблоне и стилях.

HTML-реализация блока:

```html
<a class="logo" href="/">Ваша крутая компания</a>
```
CSS-реализация блока:

```css
.logo {
    width: 150px;
    height: 100px;
    background: url(logok.png) no-repeat;
}
```
Блок `logo` в файловой структуре проекта:

```files
logo/
    logo.css        # Внешний вид блока
    logo.tmpl       # Шаблоны для генерации HTML-представления блока
```

Добавим блоку `logo` JavaScript-функциональность: клик по логотипу вызывает дополнительное действие. Согласно БЭМ-методологии файл с JavaScript-реализацией для блока `logo` будет создан следующим образом:
  * в отдельном файле;
  * имя файла будет соответствовать имени блока с расширением `.js`;
  * файл реализации будет находится в директории блока `logo/`.

JavaScript-реализация блока:

```js
$('.logo').on('click', doSomething);
```
Блок `logo` в файловой структуре проекта:

```files
logo/
    logo.css         # Внешний вид блока
    logo.tmpl        # Шаблоны для генерации HTML-представления блока
    logo.js          # Динамическое поведение блока в браузере
```

## Что описано в документе

Рассмотрим следующие вопросы:
* Для чего применяются правила БЭМ к привычному JavaScript-коду.
* Какие принципы БЭМ-методология использует в JavaScript.
* Как работает JavaScript по БЭМ.
* Пример создания формы с всплывающим окном по БЭМ.

## Зачем писать JavaScript по БЭМ

Применение принципов БЭМ-методологии в JavaScript позволяет в полной мере использовать компонентный подход в БЭМ-проектах:
  * создавать независимые компоненты — блоки;
  * работать в единых терминах блоков, элементов и модификаторов;
  * повторно использовать блоки, переносить их между проектами;
  * облегчить и ускорить разработку и отладку проекта за счет несвязанности компонентов и возможности разрабатывать по-блочно;
  * включать в сборку только нужную JavaScript-реализацию блока;
  * облегчить навигацию по проекту.

Перечисленные возможности опциональны и могут использоваться, исходя из потребностей проекта.

Чтобы максимально использовать возможности JavaScript-кода, написанного по БЭМ, и разделять код по уровням переопределения по аналогии с CSS, необходимо следовать всем принципам БЭМ-методологии: соблюдать единое именование и организацию файловой системы, использовать сборку.

## Принципы БЭМ-методологии в JavaScript

* [Декларативный стиль](#Декларативный-стиль)
* [Принципы ООП в JavaScript по БЭМ](#Принципы-ООП-в-javascript-по-БЭМ)
* [Работа с уровнями переопределения](#Работа-с-уровнями-переопределения)

### Единая предметная область

По БЭМ-методологии во всех технологиях реализации блока используется единая предметная область. В JavaScript также применяется понятие блока, который может содержать в себе элементы. Логика работы блока или его элемента описывается как набор состояний и выражается с помощью **модификаторов**. Под состоянием в БЭМ рассматривается внешний вид (CSS, шаблоны) и поведение (JavaScript) блока.

Использование одинаковых понятий в проекте для всех технологий позволяет отказаться от жесткого кодирования имен блоков и сепараторов. Если блоки и элементы используются во всех технологиях, то в JavaScript удобно реализовать различные хелперы для работы с компонентами. Например, найти внутри блока все элементы с определенным именем и выставить им модификатор, проверить его значение.

**Пример**

Есть задача показывать всплывающее окно (блок `popup`). Можно воспользоваться стандартным решением и добавлять соответствующий класс. Такой способ не всегда удобен, так как необходимо жестко кодировать имя блока:

```
$(document).ready(function(){
    $('#popup_visible').click(function(){
        popup_visible();
    });
});

function popup_visible(){
    var bg_height = $(document).height();
    var bg_width = $(window).width();
    $('.popup_bg').css({
        'width': bg_width,
        'height':bg_height
    });
}
```

Если использовать терминологию БЭМ (блоки, элементы и модификаторы), удобно реализовать хелперы для работы с ними.

### Декларативный стиль

Декларативность JavaScript в БЭМ-проекте проявляется в том, что JavaScript-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять. Это позволяет разделять функциональность блока на отдельные части и использовать уровни переопределения.

#### Декларация блока

Создание JavaScript-компонента блока сводится к его декларации с помощью специальных хелперов. Существуют различные хелперы для декларации блоков, имеющих и не имеющих [DOM-представление](#Динамические-блоки-в-dom).

Например:

```js
modules.define('my-block', ['i-bem'], function(provide, BEM) {

provide(BEM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
```

### Принципы ООП в JavaScript по БЭМ

В БЭМ-методологии к JavaScript применяются основные принципы объектно-ориентированного программирования.

#### Наследование

Поведение блока программируется в декларативном стиле в виде утверждений: `набор условий` — `реакция блока`. Это позволяет [использовать уровни переопределения](#Работа-с-уровнями-переопределения) по аналогии с CSS и **наследовать** (изменять или расширять) функциональность блока.

#### Полиморфизм

В терминах ООП все одинаковые блоки на странице рассматриваются как класс, а каждый конкретный блок — как экземпляр данного класса.

JavaScript-реализация блока описывает поведение определенного класса элементов веб-интерфейса. Экземпляр блока реализует функциональность своего класса и имеет собственное, независимое состояние, которое можно изменять (переопределять) или дополнять (доопределять).

#### Инкапсуляция

Вся функциональность блока реализуется модульно в методах класса (=блока). JavaScript-реализация одного блока отделена от другого.

Одна и та же JavaScript-логика может быть востребована в нескольких блоках проекта. Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX, или совершать однотипные операции с DOM-деревом. Чтобы избежать ненужных повторов в коде, общую функциональность можно **инкапсулировать** в виде модулей, а затем добавлять к блокам.

> Подробно о [взаимодействии блоков на уровне JavaScript](#Взаимодействие-блоков)

### Работа с уровнями переопределения

Как правило в БЭМ-проекте используется больше одного уровня переопределения. JavaScript, написанный по БЭМ, позволяет изменять или дополнять поведение блоков или его элементов по аналогии с CSS.

Уровни переопределения в JavaScript позволяют сохранять предыдущее поведение блока, наследовать и дополнять его (делать supercall). Или полностью перекрывать уже имеющееся поведение, переопределять его, не выполняя supercall.

Полная аналогия с CSS: если правило повторяется, поведение полностью перекрывается; если правило добавляется, поведение дополняется.

С помощью уровней переопределения можно создать JavaScript-библиотеку блоков, изменять ее на проектном уровне и использовать сборку, включая в проект только необходимое поведение блоков.

#### JavaScript-фреймворк

Чтобы работать с JavaScript в терминах БЭМ и использовать уровни переопределения необходим фреймворк. Если в проекте только один уровень переопределения, ограничения при выборе фреймворка отсутствуют. Если уровней несколько — необходим специализированный фреймворк, который удовлетворит требования JavaScript в БЭМ.

> В качестве примера можно рассматривать фреймворк i-bem.js.


## Особенности работы с JavaScript по БЭМ

Компонентный подход и разделение CSS-кода на отдельные файлы реализованы во многих продуктах помимо БЭМ, таких как Polymer или стандарт Web Components. Однако аналогичное разделение JavaScript-кода на независимые компоненты вызывает вопросы, так как блоки должны взаимодействовать друг с другом на уровне JavaScript:

* [Динамические блоки в DOM](#Динамические-блоки-в-dom)
* [Взаимодействие блоков](#Взаимодействие-блоков)
* [Взаимодействие блока с его элементами](#Взаимодействие-блока-с-его-элементами)
* [Работа с модификаторами](#Работа-с-модификаторами)

### Динамические блоки в DOM

Блокам с JavaScript-реализацией могут соответствовать узлы в HTML. В этом случае говорится о том, что **блоки имеют DOM-представление**.

В простейшем случае блок соответствует DOM-узлу один к одному. Важно понимать, что DOM-узел и блок — это не всегда одно и тоже. Можно разместить несколько блоков на одном DOM-узле (это называется [микс](../key-concepts/key-concepts.ru.md#Микс)), а также реализовать один блок на нескольких DOM-узлах.

> Примеры реализации доступны в i-bem.js.

Существуют **блоки без DOM-представления**. В JavaScript они представлены в виде объектов, имеющих свои методы. Эти методы используются, если нужно повлиять на внешний вид или поведение блока.

### Взаимодействие блоков

БЭМ-методология предполагает работу с независимыми блоками. Однако на практике полная независимость блоков недостижима.

Блоки могут взаимодействовать друг с другом с помощью:

* Подписки на БЭМ-события (собственные события, генерируемые блоком) других экземпляров блоков.
* Непосредственного вызова методов других экземпляров блоков или статических методов класса другого блока.
* Канала событий. Все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

> Примеры реализации смотри в i-bem.js

Взаимодействие между блоками всегда строится в иерархическом порядке. Блок не может взаимодействовать с внешними или соседними блоками, только с родительскими или дочерними.

### Взаимодействие блока с его элементами

Любое взаимодействие с элементами в БЭМ-терминах происходит через методы блока-родителя. Например, для установки/снятия модификаторов у элемента, необходимо вызвать соответствующие методы блока и передать элемент в качестве параметра. А методы, возвращающие элементы, на самом деле возвращают jQuery-коллекции, которые ничего не знают о предметной области БЭМ.

Для поиска элементов внутри блока используется метод elem.

### Работа с модификаторами

Модификатор задает блоку определенное состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.

Любой перевод блока в другое состояние должен производиться при помощи установки/снятия модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке `checkbox`, ему нужно установить модификатор `checked` в значение `true`.

Модификаторы нельзя устанавливать, напрямую меняя CSS-класс на соответствующем DOM-узле. Для корректной работы JavaScript все манипуляции с модификаторами должны производиться при помощи методов-хелперов.

#### Реакция на изменение модификаторов

В БЭМ поведение на установку/снятие модификатора описывается декларативно. Так, например, если в CSS во время исполнения появляется какой-то дополнительный класс (в частности модификатор), то все свойства этого модификатора автоматически применяются к DOM-узлу, на который этот класс установлен. В JavaScript происходит то же самое: если появляется модификатор (добавляется новый класс к DOM-узлу), то вся функциональность, свойственная этому модификатору, применяется. Если модификатор исчезает, функциональность отключается.

В БЭМ-методологии состояния блока или его элементов определяются модификаторами.  Изменение модификатора создает событие, которое можно использовать для работы с блоком.

Чтобы динамически изменять состояния блоков и элементов, используются специальные методы для установки и снятия модификаторов.

**Пример**

Рассмотрим форму отправки сообщения. Условие: если введен неправильный e-mail, кнопка (блок `button`) отправки становится недоступна (получает модификатор `button_disabled`). Можно жестко прописать все условия в коде и постоянно выполнять проверку:

```js
$('.button').on('click', function(e) {
    if (/^([a-z0-9_-]+\.)*[a-z0-9_-]+@[a-z0-9_-]+(\.[a-z0-9_-]+)*\.[a-z]{2,6}$.test($('.input').val())) {
        $('.button').addClass('button_disabled');
        return false;
    }
});
```

А можно задекларировать поведение блока и получить возможность перекрывать каждый модификатор отдельно на новом уровне переопределения. В декларации можно записать, как блок или элемент должен отреагировать на изменение модификатора.


## Пример создания формы с всплывающим окном по БЭМ

В качестве примера рассмотрим стандартную JavaScript-реализацию формы на jQuery, затем применим к ней принципы БЭМ-методологии и покажем, какие преимущества это дает.

В качестве примера возьмем форму (`form`), в которой:
* перед отправкой формы осуществляется проверка введенного значения;
* в случае ошибки показывается всплывающее окно (`popup`) с предупреждением.

```html
<form class="form" action="/">
    <input class="input" name="email">
    <input class="button" type="submit">
    <div class="popup">Пожалуйста, введите корректный email</div>
</form>
```

```css
.popup {
    display: none;
}

.popup_visible {
    display: block;
}
```

Пример реализации формы в стиле jQuery:

```js
$('.button').on('click', function(e) {
    if (!/\S+@\S+\.\S+/.test($('.input').val())) {
        $('.popup').addClass('popup_visible');
        return false;
    }
});
```

Достаточно написать шесть строк, чтобы форма начала работать. Но у такого кода есть ряд недостатков:

* Сильная связанность кода: кнопка «знает» про поле ввода (`input`) и всплывающее окно (`popup`). Кроме того, кнопка находится внутри формы (`form`).
* Проблемы при отладке кода: если какой-либо из компонентов формы исчезнет или добавится еще одно поле (`input`), код перестанет работать.
* Проблемы при повторном использовании кода: повторное использование кнопки потребует наличия всех компонентов формы с такими же классами. При этом, для правильной работы необходимо гарантировать, что на странице кнопка будет уникальна.

В результате, простой и короткий код вызовет проблемы в поддержке. Форму можно будет использовать повторно, только если создается точная копия проекта.

2 независимая JS-реализация компонентов внутри формы

Попробуем изменить код, чтобы избавиться от части перечисленных проблем:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.input', this).val())) return true;
    e.preventDefault();
    $('.popup', this).addClass('popup_visible');
});
```

Теперь компоненты внутри формы ничего не знают о существовании друг друга. Это означает, что они стали независимыми. Кнопку можно перенести в другой проект без формы, поля ввода и всплывающего окна.

Все селекторы вынесены за рамки контекста формы: теперь за пределами формы можно добавлять любое количество новых полей ввода, всплывающих окон и кнопок.

Оставшиеся недостатки:

* Добавление еще одного поля потребует изменений в коде.
* Чтобы гарантировать перекрытие всплывающим окном всех других компонентов на странице, необходимо указать его в самом конце DOM-дерева, перед закрывающим тегом `</body>`.

Использование кода все еще можно сделать удобнее. Для этого можно вынести всплывающее окно из формы и добавить еще одно поле. Сами поля необходимо [смиксовать](../definitions/definitions.ru.md#mix) с элементами формы.

Микс — это объединение нескольких блоков на одном DOM-узле.

```html
<form class="form" action="/">
    <input class="input form__login" name="login">
    <input class="input form__email" name="email">
    <input class="button" type="submit">
</form>
<div class="popup form__hint">Пожалуйста, введите корректный email</div>
```

Теперь код выглядит так:

```js
$('.form').on('submit', function(e) {
    if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
    e.preventDefault();
    $('.form__hint').addClass('popup_visible');
});
```

Такой код решает все описанные выше проблемы. Но добавляет новую: если на странице будет несколько форм, как каждая из них найдет свое всплывающее окно?

Существует несколько решений:

* Использовать паттерн MVC и обеспечить проверку формы на уровне модели.
* Реализовать механизм, который позволит выражать один блок на нескольких DOM-узлах. Схематично он может выглядеть так:

  ```html
  <form class="form" action="/" data-id="1">
      <input class="input form__login" name="login">
      <input class="input form__email" name="email">
      <input class="button" type="submit">
  </form>
  <div class="popup form form__hint" data-id="1">Пожалуйста, введите корректный email</div>
  ```

  Что сделано:
  * Форме добавлен data-атрибут с идентификатором.
  * К всплывающему окну помимо элемента примиксована форма с таким же идентификатором.

  Следующим шагом необходимо указать, что нужен элемент `hint` именно этого блока `form`:

  ```js
  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      $('.form__hint').filter('.form[data-id=' + $(this).data('id') + ']').addClass('popup_visible');
  });
  ```
* Воспользоваться паттерном проектирования «Посредник».
  Такое решение сохраняет независимость блоков и позволяет не вносить изменения в DOM.

  Компоненты формы ничего не знают друг о друге, но знают о существовании посредника. Все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

  Чтобы максимально упростить пример, сделаем таким посредником `body`. Он может обеспечить обмен сообщениями, так как всегда присутствует в коде и может знать обо всех компонентах на странице.

  ```html
  <body class="page">
      <form class="form" action="/">
          <input class="input form__login" name="login">
          <input class="input form__email" name="email">
          <input class="button" type="submit">
      </form>
      <div class="popup"></div>
  </body>
  ```

  ```js
  var page = $('.page');

  page.on('error', function(e, data) {
      $('.popup')
          .text(data)
          .addClass('popup_visible');
  });

  $('.form').on('submit', function(e) {
      if (/\S+@\S+\.\S+/.test($('.form__email', this).val())) return true;
      e.preventDefault();
      page.trigger('error', 'Ошибка валидации');
  });
  ```

  Теперь в случае ошибки, форма сообщит об этом посреднику — `page`. Все компоненты, которые должны реагировать на это событие, могут «подписаться» на него через `page.on()`.


Разделение JavaScript-реализации на файлы помогает сохранять независимость блоков, упрощает отладку и повторное использование кода.
